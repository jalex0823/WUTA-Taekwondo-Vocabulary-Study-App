<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    
    <!-- PWA / Mobile Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WUTA Taekwondo">
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="{{ url_for('static', filename='icon-180.png') }}">
    <link rel="apple-touch-icon" sizes="152x152" href="{{ url_for('static', filename='icon-152.png') }}">
    <link rel="apple-touch-icon" sizes="167x167" href="{{ url_for('static', filename='icon-167.png') }}">
    <link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', filename='icon-180.png') }}">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">

    <!-- PWA Manifest (Android/Chrome + modern iOS support) -->
    <link rel="manifest" href="{{ url_for('static', filename='manifest.webmanifest') }}">
    
    <meta name="theme-color" content="#667eea">
    
    <title>{{ belt.belt_name }} - WUTA Vocabulary</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    
    <!-- Confetti is implemented locally (see inline script) to avoid third-party tracking/storage warnings. -->
</head>
<body class="theme-arcade theme-screenshot page-terms">
    <div class="container">
        <header class="terms-header" style="--belt-color: {{ belt.belt_color }}">
            <div class="terms-brand" aria-hidden="true">
                <picture class="terms-brand-mascot">
                    <img
                        src="{{ url_for('static', filename='images/TVTA_Neal.png') }}"
                        alt=""
                        loading="eager"
                        onerror="this.onerror=null; this.src='{{ url_for('static', filename='images/branding/mascot.svg') }}';"
                    >
                </picture>
            </div>
            <a href="/" class="back-button">‚Üê Back to Main Menu</a>
            <h1>{{ belt.belt_name }}</h1>
            <p class="term-counter">
                <span id="current-term">1</span> / {{ belt.terms|length }}
                <span class="completion-badge" id="completionBadge">0%</span>
            </p>
        </header>

        <div class="music-controls" aria-label="Background music controls">
            <div class="music-controls__row">
                <span class="music-controls__label" id="bgmLabel">üéµ Music</span>
                <button class="music-toggle" id="bgmToggle" type="button" aria-pressed="true">Music: ON</button>
            </div>
            <div class="music-controls__row">
                <label class="music-controls__vol" for="bgmVolume">Volume</label>
                <input id="bgmVolume" class="music-volume" type="range" min="0" max="100" step="1" value="22" />
            </div>
        </div>

        <div class="mode-controls">
            <div class="translation-toggle-row">
                <button class="translation-toggle tkd-translate-toggle" id="translationToggle" type="button" onclick="toggleTranslation()" aria-pressed="true">
                    Translation: ON
                </button>
            </div>

            <div class="mode-toggle">
                <button class="mode-btn active" id="manualModeBtn" onclick="setMode('manual')">
                    <span class="mode-icon">üëÜ</span>
                    Manual
                </button>
                <button class="mode-btn" id="autoModeBtn" onclick="setMode('auto')">
                    <span class="mode-icon">‚ñ∂Ô∏è</span>
                    Auto Guide
                </button>
            </div>
            
            <div class="auto-controls hidden" id="autoControls">
                <div class="auto-guide-banner" aria-label="How Auto Guide works">
                    <div class="auto-guide-steps" aria-hidden="true">
                        <span class="step">üá∞üá∑ Listen</span>
                        <span class="arrow">‚Üí</span>
                        <span class="step">üá∫üá∏ Repeat</span>
                        <span class="arrow">‚Üí</span>
                        <span class="step">‚û°Ô∏è Next</span>
                    </div>
                    <div class="auto-guide-sub">Plays through {{ total_terms }} cards</div>

                    <details class="auto-guide-help">
                        <summary>Need help?</summary>
                        <div class="help-text">
                            If you only hear Korean, try refreshing the page. If it still happens, clear browser cache or ask an admin to clear server audio files.
                        </div>
                    </details>
                </div>
                <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin-bottom: 10px;">
                    <div class="repeat-time-control" style="flex: 1;">
                        <label>Pause Between Words:</label>
                        <select id="repeatTimeSelect" onchange="updateRepeatTime()">
                            <option value="2">2 sec</option>
                            <option value="3">3 sec</option>
                            <option value="5" selected>5 sec</option>
                            <option value="7">7 sec</option>
                        </select>
                    </div>

                    <div class="repeat-time-control" style="flex: 1;">
                        <label>Repeat Card:</label>
                        <select id="autoRepeatSelect" onchange="updateAutoRepeatCount()">
                            <option value="1" selected>1x</option>
                            <option value="2">2x</option>
                            <option value="3">3x</option>
                        </select>
                    </div>
                </div>
                <button class="auto-btn play-btn" id="playPauseBtn" onclick="toggleAutoPlay()" style="width: 100%; padding: 15px; font-size: 18px;">
                    <span id="playPauseIcon">‚ñ∂Ô∏è</span>
                    <span id="playPauseText">üéµ Start Auto Play - Korean + English</span>
                </button>
                <div class="auto-progress-indicator">
                    <div class="progress-ring">
                        <svg width="40" height="40">
                            <circle class="progress-ring-circle" cx="20" cy="20" r="16" 
                                    stroke-width="3" fill="transparent" stroke="#e0e0e0"/>
                            <circle class="progress-ring-circle-active" id="progressCircle" 
                                    cx="20" cy="20" r="16" stroke-width="3" fill="transparent" 
                                    stroke="#4ECDC4" stroke-dasharray="100.53 100.53" 
                                    stroke-dashoffset="100.53" transform="rotate(-90 20 20)"/>
                        </svg>
                        <span class="progress-text" id="progressText">5</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="flashcard-container">
            {% for t in belt.terms %}
            <div class="flashcard {% if loop.first %}active{% endif %}"
                 data-term-index="{{ loop.index0 }}"
                 data-hangul="{{ t.hangul }}"
                 data-romanization="{{ t.romanization }}"
                 data-english="{{ t.english }}"
                 data-category="{{ t.category }}"
                 data-image="{{ t.image_path or '' }}">
                <div class="card-inner">
                    <div class="card-front">
                        <div class="ref-card" aria-label="Vocabulary card">
                            <div class="ref-mascot" aria-hidden="true">
                                <img
                                    src="{{ url_for('static', filename='images/TVTA_Neal.png') }}"
                                    alt=""
                                    loading="eager"
                                    onerror="this.onerror=null; this.src='{{ url_for('static', filename='images/branding/mascot.svg') }}';"
                                >
                            </div>

                            <div class="ref-belt">{{ belt.belt_name }}</div>

                            <div class="ref-divider" aria-hidden="true"></div>

                            <div class="ref-hangul">{{ t.hangul }}</div>
                            <div class="ref-roman">{{ t.romanization }}</div>

                            <div class="ref-english-row">
                                <div class="ref-english">{{ t.english }}</div>
                            </div>

                            <div class="ref-definition">Category: {{ t.category }}</div>

                            <button class="ref-read" type="button" onclick="playAudio('{{ t.id }}', this, true)" title="Read Card">
                                <span class="ref-read__ico" aria-hidden="true">üîä</span>
                                <span class="ref-read__txt">Read Card</span>
                            </button>

                            <div class="audio-visualizer hidden" aria-hidden="true">
                                <div class="bar"></div>
                                <div class="bar"></div>
                                <div class="bar"></div>
                                <div class="bar"></div>
                                <div class="bar"></div>
                            </div>

                            <div class="ref-divider ref-divider--bottom" aria-hidden="true"></div>

                            <div class="ref-nav" aria-label="Card navigation">
                                <button class="ref-navbtn ref-navbtn--prev" type="button" onclick="prevCard()">Previous &lt;</button>
                                <button class="ref-navbtn ref-navbtn--next" type="button" onclick="nextCard()">Next &gt;</button>
                            </div>
                        </div>
                    </div>

                    <div class="card-back">
                        <div class="romanization">{{ t.romanization }}</div>
                        <div class="english-text">{{ t.english }}</div>

                        <div class="tap-hint" aria-hidden="true">üëÜ Tap the card to go back</div>
                        
                        {% if t.image_path %}
                        <div class="move-image-container">
                            <img src="{{ t.image_path }}" alt="{{ t.english }} demonstration" class="move-image">
                        </div>
                        {% endif %}
                        
                        <div class="hangul-small">{{ t.hangul }}</div>
                        
                        <button class="flip-button" onclick="flipCard(this)">
                            ‚Üê Back to Korean
                        </button>
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>

        <div class="navigation-controls">
            <button class="nav-button" id="prevBtn" onclick="prevCard()" disabled>
                ‚Üê Previous
            </button>
            <button class="nav-button primary" id="nextBtn" onclick="nextCard()">
                Next ‚Üí
            </button>
            <a class="nav-button" href="/" title="Back to Main Menu">üè† Main Menu</a>
        </div>

        <div class="progress-dots">
            {% for t in belt.terms %}
            <span class="dot {% if loop.first %}active{% endif %}" onclick="goToCard({{ loop.index0 }})"></span>
            {% endfor %}
        </div>

    </div>

    <script src="{{ url_for('static', filename='wuta_audio.js') }}"></script>
    <script>
        // ============ TINY LOCAL CONFETTI (NO EXTERNAL CDN) ============
        // Minimal confetti implementation to avoid third-party script warnings.
        // API-compatible enough for the calls in celebrateCompletion().
        (function () {
            if (window.confetti) return;

            function rand(min, max) { return Math.random() * (max - min) + min; }

            const COLORS = ['#ff6b6b', '#4ecdc4', '#ffd93d', '#667eea', '#764ba2', '#4caf50', '#ff8800'];
            let canvas;
            let ctx;
            let particles = [];
            let rafId = null;

            function ensureCanvas() {
                if (canvas && ctx) return;
                canvas = document.createElement('canvas');
                canvas.style.position = 'fixed';
                canvas.style.left = '0';
                canvas.style.top = '0';
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '9999';
                document.body.appendChild(canvas);
                ctx = canvas.getContext('2d');

                const resize = () => {
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = Math.floor(window.innerWidth * dpr);
                    canvas.height = Math.floor(window.innerHeight * dpr);
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                };
                resize();
                window.addEventListener('resize', resize);
            }

            function tick() {
                if (!ctx) return;
                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                const gravity = 900; // px/s^2
                const now = performance.now();

                particles = particles.filter(p => now < p.end);
                for (const p of particles) {
                    const dt = (now - p.last) / 1000;
                    p.last = now;

                    p.vy += gravity * dt;
                    p.vx *= p.decay;
                    p.vy *= p.decay;

                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.rot += p.vr * dt;

                    const life = (p.end - now) / (p.end - p.start);
                    const alpha = Math.max(0, Math.min(1, life));

                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rot);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
                    ctx.restore();
                }

                if (particles.length > 0) {
                    rafId = requestAnimationFrame(tick);
                } else {
                    if (rafId) cancelAnimationFrame(rafId);
                    rafId = null;
                    // Remove canvas after we finish to keep DOM clean.
                    try { canvas.remove(); } catch (e) {}
                    canvas = null;
                    ctx = null;
                }
            }

            window.confetti = function (opts = {}) {
                ensureCanvas();

                const particleCount = Math.max(0, Math.min(400, opts.particleCount || 80));
                const origin = opts.origin || { y: 0.7, x: 0.5 };
                const spread = (opts.spread ?? 60) * (Math.PI / 180);
                const startVelocity = opts.startVelocity ?? 45;
                const decay = opts.decay ?? 0.92;
                const scalar = opts.scalar ?? 1;

                const startX = (origin.x ?? 0.5) * window.innerWidth;
                const startY = (origin.y ?? 0.7) * window.innerHeight;
                const now = performance.now();

                for (let i = 0; i < particleCount; i++) {
                    const angle = rand(-spread / 2, spread / 2) + (-Math.PI / 2);
                    const speed = rand(startVelocity * 0.5, startVelocity * 1.1);
                    particles.push({
                        x: startX,
                        y: startY,
                        vx: Math.cos(angle) * speed * rand(0.8, 1.2),
                        vy: Math.sin(angle) * speed * rand(0.8, 1.2),
                        w: rand(6, 10) * scalar,
                        h: rand(10, 16) * scalar,
                        rot: rand(0, Math.PI * 2),
                        vr: rand(-8, 8),
                        color: COLORS[Math.floor(rand(0, COLORS.length))],
                        decay,
                        start: now,
                        end: now + rand(900, 1400),
                        last: now,
                    });
                }

                if (!rafId) rafId = requestAnimationFrame(tick);
            };
        })();

        let currentCard = 0;
        const totalCards = {{ belt.terms|length }};
        let currentAudio = null;
        let currentMode = 'manual';
        let isAutoPlaying = false;
        let repeatTime = 5; // seconds
        let autoRepeatCount = 1; // times to repeat audio per card in Auto Guide
        let countdownInterval = null;
        let progressTimeout = null;
        
        const terms = {{ belt.terms | tojson }};
        
        // ============ SOUND EFFECTS & HAPTICS ============
        
        // Pre-load sound effects
        const soundEffects = {
            click: new Audio('{{ url_for("static", filename="audio/sfx/button_click.mp3") }}'),
            nav: new Audio('{{ url_for("static", filename="audio/sfx/nav_swoosh.mp3") }}'),
            mode: new Audio('{{ url_for("static", filename="audio/sfx/mode_toggle.mp3") }}'),
            flip: new Audio('{{ url_for("static", filename="audio/sfx/card_flip.mp3") }}'),
            success: new Audio('{{ url_for("static", filename="audio/sfx/success.mp3") }}')
        };
        
        // Set volume for all sound effects
        Object.values(soundEffects).forEach(sound => {
            sound.volume = 0.3;
            sound.preload = 'auto';
        });
        
        // Play sound effect helper
        function playSFX(soundName) {
            if (soundEffects[soundName]) {
                soundEffects[soundName].currentTime = 0; // Reset to start
                soundEffects[soundName].play().catch(e => console.log('Audio play prevented:', e));
            }
        }
        
        // Create sound effect using Web Audio API (fallback)
        // IMPORTANT: many browsers require a user gesture before AudioContext can run.
        let audioContext = null;
        let audioUnlocked = false;
        let unlockPromptShown = false;

        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        function showAudioUnlockPrompt(message = 'Tap anywhere once to enable audio') {
            if (unlockPromptShown) return;
            unlockPromptShown = true;

            const header = document.querySelector('.terms-header');
            if (!header) return;

            const prompt = document.createElement('div');
            prompt.id = 'audioUnlockPrompt';
            prompt.style.cssText = [
                'margin-top: 10px',
                'padding: 10px 12px',
                'border-radius: 10px',
                'background: rgba(255, 193, 7, 0.18)',
                'border: 1px solid rgba(255, 193, 7, 0.45)',
                'color: rgba(0,0,0,0.85)',
                'font-size: 13px',
                'text-align: center'
            ].join(';');
            prompt.textContent = `üîá ${message}`;
            header.appendChild(prompt);
        }

        function hideAudioUnlockPrompt() {
            const prompt = document.getElementById('audioUnlockPrompt');
            if (prompt) prompt.remove();
        }

        // Unlock audio playback on first user gesture.
        // This reduces NotAllowedError spam on iOS/Safari/Chrome when trying to autoplay.
        async function unlockAudio() {
            if (audioUnlocked) return true;
            try {
                const ctx = getAudioContext();
                if (ctx.state === 'suspended') {
                    await ctx.resume();
                }

                // Create a tiny silent buffer and play it. This frequently ‚Äúunlocks‚Äù HTMLAudio too.
                const buffer = ctx.createBuffer(1, 1, 22050);
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                source.connect(ctx.destination);
                source.start(0);

                audioUnlocked = true;
                hideAudioUnlockPrompt();
                return true;
            } catch (e) {
                console.warn('Audio unlock failed:', e);
                showAudioUnlockPrompt('Audio is blocked. Tap once to enable sound.');
                return false;
            }
        }
        
        function playSuccessSound() {
            playSFX('success');
            const ctx = getAudioContext();
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.3);
        }
        
        function playTapSound() {
            const ctx = getAudioContext();
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);
            
            oscillator.frequency.value = 400;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
            
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.1);
        }
        
        function playCompleteSound() {
            // Play a cheerful melody
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C (octave higher)
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    const ctx = getAudioContext();
                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    oscillator.frequency.value = freq;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                    
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.3);
                }, index * 100);
            });
        }
        
        function vibrateDevice(pattern = [100]) {
            if ('vibrate' in navigator) {
                navigator.vibrate(pattern);
            }
        }
        
        function celebrateCompletion() {
            playCompleteSound();
            vibrateDevice([200, 100, 200, 100, 200]);
            
            // Confetti burst!
            const count = 200;
            const defaults = {
                origin: { y: 0.7 }
            };
            
            function fire(particleRatio, opts) {
                confetti(Object.assign({}, defaults, opts, {
                    particleCount: Math.floor(count * particleRatio)
                }));
            }
            
            fire(0.25, {
                spread: 26,
                startVelocity: 55,
            });
            
            fire(0.2, {
                spread: 60,
            });
            
            fire(0.35, {
                spread: 100,
                decay: 0.91,
                scalar: 0.8
            });
            
            fire(0.1, {
                spread: 120,
                startVelocity: 25,
                decay: 0.92,
                scalar: 1.2
            });
            
            fire(0.1, {
                spread: 120,
                startVelocity: 45,
            });
        }
        
        function showStarBurst(element) {
            const star = document.createElement('div');
            star.className = 'star-burst';
            star.innerHTML = '‚≠ê';
            element.appendChild(star);
            
            setTimeout(() => star.remove(), 1000);
        }

        // ============ COMPLETION TRACKING ============
        
        const STORAGE_KEY = 'wuta_completion_';
        let viewedTerms = new Set();
        
        function loadProgress() {
            const beltId = '{{ belt.belt_id }}';
            const stored = localStorage.getItem(STORAGE_KEY + beltId);
            if (stored) {
                try {
                    viewedTerms = new Set(JSON.parse(stored));
                } catch (e) {
                    viewedTerms = new Set();
                }
            }

            // Migrate legacy term IDs (if terms.json was updated).
            // If a term has legacy_id and the user had previously viewed legacy_id,
            // we count it as viewed for the new id.
            try {
                let changed = false;
                for (const term of terms) {
                    if (term.legacy_id && viewedTerms.has(term.legacy_id) && !viewedTerms.has(term.id)) {
                        viewedTerms.add(term.id);
                        changed = true;
                    }
                }
                if (changed) saveProgress();
            } catch (e) {
                // Non-fatal: ignore migration errors.
            }
            updateCompletionBadge();
        }
        
        function saveProgress() {
            const beltId = '{{ belt.belt_id }}';
            localStorage.setItem(STORAGE_KEY + beltId, JSON.stringify([...viewedTerms]));
        }
        
        function markTermViewed(termId) {
            viewedTerms.add(termId);
            saveProgress();
            updateCompletionBadge();
        }
        
        function updateCompletionBadge() {
            const completionPercentage = Math.round((viewedTerms.size / totalCards) * 100);
            const badge = document.getElementById('completionBadge');
            badge.textContent = completionPercentage + '%';
            
            // Add color coding
            badge.className = 'completion-badge';
            if (completionPercentage === 100) {
                badge.classList.add('complete');
            } else if (completionPercentage >= 50) {
                badge.classList.add('halfway');
            }
        }
        
        function resetProgress() {
            if (confirm('Reset progress for this belt level?')) {
                viewedTerms.clear();
                saveProgress();
                updateCompletionBadge();
            }
        }

        function showCard(index) {
            document.querySelectorAll('.flashcard').forEach((card, i) => {
                card.classList.toggle('active', i === index);
                // Reset flip when changing cards
                card.querySelector('.card-inner').classList.remove('flipped');
            });
            
            document.querySelectorAll('.dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });

            document.getElementById('current-term').textContent = index + 1;
            document.getElementById('prevBtn').disabled = index === 0;
            document.getElementById('nextBtn').disabled = index === totalCards - 1;

            // Reference-style in-card nav buttons (if present)
            try {
                const active = document.querySelector('.flashcard.active');
                const prev = active?.querySelector('.ref-navbtn--prev');
                const next = active?.querySelector('.ref-navbtn--next');
                if (prev) prev.disabled = index === 0;
                if (next) next.disabled = index === totalCards - 1;
            } catch (e) {}
            
            // Mark term as viewed
            const termId = terms[index].id;
            markTermViewed(termId);

            // Stop any playing audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                document.querySelectorAll('.audio-visualizer').forEach(v => v.classList.add('hidden'));
            }

            // Stop any speech (Web Speech API)
            try {
                if (window.speechSynthesis) {
                    window.speechSynthesis.cancel();
                }
            } catch (e) {}
            
            // Clear any existing countdown
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            if (progressTimeout) {
                clearTimeout(progressTimeout);
                progressTimeout = null;
            }
            resetProgressRing();
        }

        function nextCard() {
            if (currentCard < totalCards - 1) {
                playSFX('nav');
                playTapSound();
                vibrateDevice([30]);
                // Next click is a user gesture: ensure audio is unlocked for immediate playback.
                unlockAudio();
                currentCard++;
                showCard(currentCard);
                // Auto-play audio in both modes
                if (currentMode === 'auto' && isAutoPlaying) {
                    playCurrentCardAuto();
                } else if (currentMode === 'manual') {
                    // Play audio automatically when clicking Next
                    playAudioForCurrentCard();
                }
            } else if (isAutoPlaying && currentMode === 'auto') {
                // End of list in auto mode
                stopAutoPlay();
                celebrateCompletion();
                setTimeout(() => {
                    alert('üéâ Amazing work! You completed all terms! ü•ã‚≠ê');
                }, 500);
            }
        }

        function prevCard() {
            if (currentCard > 0) {
                playSFX('nav');
                playTapSound();
                vibrateDevice([30]);
                // Previous click is a user gesture: ensure audio is unlocked for immediate playback.
                unlockAudio();
                currentCard--;
                showCard(currentCard);
                // Play audio automatically when clicking Previous in manual mode
                if (currentMode === 'manual') {
                    playAudioForCurrentCard();
                }
            }
        }

        function goToCard(index) {
            playSFX('nav');
            playTapSound();
            vibrateDevice([20]);
            currentCard = index;
            showCard(currentCard);
            if (isAutoPlaying && currentMode === 'auto') {
                playCurrentCardAuto();
            }
        }

        function flipCard(button) {
            playSFX('flip');
            playTapSound();
            vibrateDevice([30]);
            const cardInner = button.closest('.card-inner');
            cardInner.classList.toggle('flipped');
        }

        function _speakCardText(term, cardEl, visualizer, includeEnglish) {
            if (!('speechSynthesis' in window) || !('SpeechSynthesisUtterance' in window)) {
                return false;
            }

            // Backwards compatible signature:
            // - includeEnglish: boolean
            // - includeEnglish: { includeEnglish, koreanRate, englishRate, pauseMs }
            const opts = (includeEnglish && typeof includeEnglish === 'object') ? includeEnglish : { includeEnglish };

            const wantEnglish = (opts.includeEnglish === undefined) ? !!window.translationEnabled : !!opts.includeEnglish;
            const koRate = (typeof opts.koreanRate === 'number') ? opts.koreanRate : 0.68;
            const enRate = (typeof opts.englishRate === 'number') ? opts.englishRate : 0.92;
            const pauseMs = (typeof opts.pauseMs === 'number') ? opts.pauseMs : 420;

            const sequence = [];
            const hangul = (term?.hangul || '').trim();
            const romanization = (term?.romanization || '').trim();
            const english = (term?.english || '').trim();

            // WUTA is a Korean vocabulary study app: always speak Korean first (slowly), then English (optional).
            if (hangul) {
                sequence.push({ text: hangul, lang: 'ko-KR', rate: koRate });
            } else if (romanization) {
                // Fallback only if Hangul is missing.
                sequence.push({ text: romanization, lang: 'en-US', rate: enRate });
            }
            if (wantEnglish && english) sequence.push({ text: english, lang: 'en-US', rate: enRate });

            if (sequence.length === 0) return false;

            try {
                // Cancel anything currently speaking.
                window.speechSynthesis.cancel();

                if (visualizer) visualizer.classList.remove('hidden');

                const speakNext = (idx) => {
                    if (idx >= sequence.length) {
                        if (visualizer) visualizer.classList.add('hidden');
                        return;
                    }
                    const item = sequence[idx];
                    const utter = new SpeechSynthesisUtterance(item.text);
                    utter.lang = item.lang;
                    utter.rate = item.rate ?? 1;
                    utter.onend = () => {
                        // Small pause between Korean and English for clarity.
                        setTimeout(() => speakNext(idx + 1), pauseMs);
                    };
                    utter.onerror = () => {
                        // Hide visualizer and stop the chain on any error.
                        if (visualizer) visualizer.classList.add('hidden');
                    };
                    window.speechSynthesis.speak(utter);
                };

                speakNext(0);
                return true;
            } catch (e) {
                try { if (visualizer) visualizer.classList.add('hidden'); } catch (e2) {}
                return false;
            }
        }

        function playAudio(termId, button, forceBilingual = false) {
            playTapSound();
            vibrateDevice([30]);

            // User explicitly clicked the speaker: use this gesture to unlock audio.
            unlockAudio();
            
            const cardRoot = button?.closest?.('.flashcard') || null;
            const visualizer = (cardRoot && cardRoot.querySelector('.audio-visualizer')) ? cardRoot.querySelector('.audio-visualizer') : button.nextElementSibling;

            // If forceBilingual is true (Read Card), always do Korean then English.
            const includeEnglish = forceBilingual ? true : !!window.translationEnabled;
            const audioUrl = includeEnglish ? `/audio/${termId}` : `/audio/${termId}?mode=korean`;
            
            // Stop previous audio if playing
            if (currentAudio) {
                currentAudio.pause();
                document.querySelectorAll('.audio-visualizer').forEach(v => v.classList.add('hidden'));
            }

            // Stop any speech currently playing.
            try {
                if (window.speechSynthesis) {
                    window.speechSynthesis.cancel();
                }
            } catch (e) {}

            // Prefer "read the card" (device TTS) so it always matches what's displayed.
            // If not supported or it fails, fall back to the server-generated MP3.
            try {
                const term = terms.find(t => t.id === termId) || terms.find(t => t.legacy_id === termId);
                const cardEl = button.closest('.flashcard');
                const ttsOpts = forceBilingual
                    ? { includeEnglish: true, koreanRate: 0.56, englishRate: 0.92, pauseMs: 700 }
                    : includeEnglish;
                const spoke = _speakCardText(term, cardEl, visualizer, ttsOpts);
                if (spoke) {
                    currentAudio = null;
                    return;
                }
            } catch (e) {
                // Ignore and fall back to MP3.
            }

            currentAudio = new Audio(audioUrl);
            visualizer.classList.remove('hidden');
            
            currentAudio.play().catch(err => {
                console.error('Error playing audio:', err);
                visualizer.classList.add('hidden');
                showAudioUnlockPrompt('Audio is blocked. Tap once, then press üîä again.');
            });

            currentAudio.onended = () => {
                visualizer.classList.add('hidden');
                currentAudio = null;
            };
        }

        function playAudioForCurrentCard() {
            const term = terms[currentCard];
            const audioUrl = window.translationEnabled ? `/audio/${term.id}` : `/audio/${term.id}?mode=korean`;
            
            // Stop previous audio if playing
            if (currentAudio) {
                currentAudio.pause();
                document.querySelectorAll('.audio-visualizer').forEach(v => v.classList.add('hidden'));
            }

            const activeCard = document.querySelector('.flashcard.active');
            const visualizer = activeCard.querySelector('.audio-visualizer');

            // Prefer device TTS when possible (still counts as a user gesture when Next/Prev was clicked).
            try {
                const speakerBtn = activeCard.querySelector('.audio-button');
                const spoke = _speakCardText(term, activeCard, visualizer, !!window.translationEnabled);
                if (spoke) {
                    currentAudio = null;
                    return;
                }
            } catch (e) {
                // Ignore and fall back to MP3.
            }

            currentAudio = new Audio(audioUrl);
            visualizer.classList.remove('hidden');

            currentAudio.play().catch(err => {
                console.error('Error playing audio:', err);
                visualizer.classList.add('hidden');
                // Browser blocked autoplay - user needs to click the speaker button first
                // Show a helpful message only once
                if (!window.audioPermissionShown) {
                    window.audioPermissionShown = true;
                    showAudioUnlockPrompt('Tap üîä once to enable audio (browser policy)');
                    const speakerBtn = activeCard.querySelector('.audio-button');
                    if (speakerBtn) {
                        speakerBtn.style.animation = 'pulse 1s ease-in-out 3';
                        setTimeout(() => {
                            speakerBtn.style.animation = '';
                        }, 3000);
                    }
                }
            });

            currentAudio.onended = () => {
                visualizer.classList.add('hidden');
                currentAudio = null;
            };
        }

        // ============ TRANSLATION TOGGLE ============
        window.translationEnabled = true;

        function _loadTranslationSetting() {
            try {
                // Prefer the new key, but stay backwards compatible.
                const rawNew = localStorage.getItem('translationEnabled');
                if (rawNew !== null) return rawNew === 'true';

                const rawOld = localStorage.getItem('wuta_translation_enabled');
                if (rawOld !== null) return rawOld === 'true';

                // Default: ON (keeps existing behavior)
                return true;
            } catch (e) {
                return true;
            }
        }

        function _setTranslationSetting(enabled) {
            window.translationEnabled = !!enabled;
            try {
                // Write both keys so older builds and newer logic stay in sync.
                localStorage.setItem('translationEnabled', String(window.translationEnabled));
                localStorage.setItem('wuta_translation_enabled', String(window.translationEnabled));
            } catch (e) {}
            _renderTranslationToggle();
        }

        function _renderTranslationToggle() {
            const btn = document.getElementById('translationToggle');
            if (!btn) return;
            const on = !!window.translationEnabled;
            btn.textContent = on ? 'Translation: ON' : 'Translation: OFF';
            btn.setAttribute('aria-pressed', on ? 'true' : 'false');
            btn.classList.toggle('is-on', on);
            btn.classList.toggle('is-off', !on);

            // Keep the card UI in sync.
            try {
                document.body.classList.toggle('translation-off', !on);
            } catch (e) {}

            // Reference-style API: body[data-translation]
            try {
                document.body.dataset.translation = on ? 'on' : 'off';
            } catch (e) {}

            // Also expose a data-attribute for CSS rules (requested API).
            try {
                const fc = document.querySelector('.flashcard-container');
                if (fc) fc.dataset.translation = on ? 'on' : 'off';
            } catch (e) {}

            // Keep Auto Play button label in sync when not currently playing.
            try {
                if (!window.isAutoPlaying) {
                    const playPauseText = document.getElementById('playPauseText');
                    if (playPauseText) {
                        // Auto Guide always plays Korean + English.
                        playPauseText.textContent = 'üéµ Start Auto Play - Korean + English';
                    }
                }
            } catch (e) {}
        }

        function toggleTranslation() {
            playSFX('mode');
            playTapSound();
            vibrateDevice([20]);

            // Stop anything currently speaking/playing so the new mode applies immediately.
            try { if (window.speechSynthesis) window.speechSynthesis.cancel(); } catch (e) {}
            try {
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio = null;
                }
            } catch (e) {}
            document.querySelectorAll('.audio-visualizer').forEach(v => v.classList.add('hidden'));

            _setTranslationSetting(!window.translationEnabled);
        }

        // Initialize translation toggle UI/state.
        window.addEventListener('DOMContentLoaded', () => {
            _setTranslationSetting(_loadTranslationSetting());
        });

        // Initialize background music (Polar Serenade) on this page.
        window.addEventListener('DOMContentLoaded', () => {
            try {
                if (window.WutaAudio && typeof window.WutaAudio.initBgm === 'function') {
                    window.WutaAudio.initBgm({
                        src: '{{ url_for("static", filename="audio/sfx/Polar_Serenade.mp3") }}',
                        enabledDefault: true,
                        volumeDefault: 0.22,
                        toggleId: 'bgmToggle',
                        volumeId: 'bgmVolume',
                        labelId: 'bgmLabel'
                    });
                }
            } catch (e) {}
        });

        // ============ MODE SWITCHING ============
        
        function setMode(mode) {
            playSFX('mode');
            playTapSound();
            vibrateDevice([50]);
            
            currentMode = mode;
            const manualBtn = document.getElementById('manualModeBtn');
            const autoBtn = document.getElementById('autoModeBtn');
            const autoControls = document.getElementById('autoControls');
            
            if (mode === 'manual') {
                manualBtn.classList.add('active');
                autoBtn.classList.remove('active');
                autoControls.classList.add('hidden');
                stopAutoPlay();
            } else {
                autoBtn.classList.add('active');
                manualBtn.classList.remove('active');
                autoControls.classList.remove('hidden');
                // Show ready state - user must click Start button for browser autoplay policy
            }
        }

        function updateRepeatTime() {
            playTapSound();
            vibrateDevice([30]);
            repeatTime = parseInt(document.getElementById('repeatTimeSelect').value);
        }

        function updateAutoRepeatCount() {
            playTapSound();
            vibrateDevice([30]);
            const el = document.getElementById('autoRepeatSelect');
            if (!el) return;
            const v = parseInt(el.value);
            autoRepeatCount = Number.isFinite(v) ? Math.max(1, Math.min(3, v)) : 1;
        }

        // ============ AUTO-PROGRESSION ============
        
        function toggleAutoPlay() {
            playSFX('click');
            playTapSound();
            vibrateDevice([50]);
            
            if (isAutoPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }

        function startAutoPlay() {
            isAutoPlaying = true;
            const playPauseBtn = document.getElementById('playPauseBtn');
            const playPauseIcon = document.getElementById('playPauseIcon');
            const playPauseText = document.getElementById('playPauseText');
            
            playPauseBtn.classList.add('playing');
            playPauseBtn.style.padding = '12px';
            playPauseBtn.style.fontSize = '16px';
            playPauseIcon.textContent = '‚è∏Ô∏è';
            playPauseText.textContent = 'Pause Auto Play';

            // The Start button click is a user gesture: unlock audio here.
            // If unlock still fails, continue auto-advance but show the prompt.
            unlockAudio().finally(() => {
                playCurrentCardAuto();
            });
        }

        function stopAutoPlay() {
            isAutoPlaying = false;
            const playPauseBtn = document.getElementById('playPauseBtn');
            const playPauseIcon = document.getElementById('playPauseIcon');
            const playPauseText = document.getElementById('playPauseText');
            
            playPauseBtn.classList.remove('playing');
            playPauseBtn.style.padding = '15px';
            playPauseBtn.style.fontSize = '18px';
            playPauseIcon.textContent = '‚ñ∂Ô∏è';
            // Auto Guide always plays Korean + English.
            playPauseText.textContent = 'üéµ Resume Auto Play - Korean + English';
            
            // Clear timers
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            if (progressTimeout) {
                clearTimeout(progressTimeout);
                progressTimeout = null;
            }
            
            // Stop audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                document.querySelectorAll('.audio-visualizer').forEach(v => v.classList.add('hidden'));
            }
            
            resetProgressRing();
            
            // Celebrate if we reached the end
            if (currentCard === totalCards - 1) {
                celebrateCompletion();
            }
        }

        function playCurrentCardAuto() {
            if (!isAutoPlaying) return;

            if (!audioUnlocked) {
                // If audio isn't unlocked, avoid calling play() repeatedly.
                // Still auto-advance so the session continues.
                showAudioUnlockPrompt('Tap once to enable audio for Auto Guide');
                startCountdown();
                return;
            }
            
            const term = terms[currentCard];
            // Auto Guide should always speak Korean THEN English, even if Translation is OFF.
            const audioUrl = `/audio/${term.id}`;
            
            // Stop previous audio
            if (currentAudio) {
                currentAudio.pause();
            }
            
            // Play audio - bilingual: Korean + pause + English
            // Repeat (optional) before starting the between-cards countdown.
            currentAudio = new Audio(audioUrl);
            const activeCard = document.querySelector('.flashcard.active');
            const visualizer = activeCard.querySelector('.audio-visualizer');
            
            visualizer.classList.remove('hidden');
            
            const repeatTotal = Math.max(1, autoRepeatCount || 1);
            let repeatsRemaining = repeatTotal;

            const handleError = (err) => {
                console.error('Error playing audio in auto mode:', err);
                visualizer.classList.add('hidden');

                // IMPORTANT: Still advance even if audio fails
                // This ensures auto-mode continues even with old cached audio or network issues
                if (isAutoPlaying) {
                    // If first card fails, show alert once
                    if (currentCard === 0 && !window.audioAutoplayWarned) {
                        window.audioAutoplayWarned = true;
                        showAudioUnlockPrompt('Audio blocked by browser. Tap once to enable sound.');
                    }
                    // Start countdown anyway so we still auto-advance
                    startCountdown();
                }
            };

            const handleEnded = () => {
                visualizer.classList.add('hidden');
                repeatsRemaining -= 1;

                // Repeat the full bilingual audio if requested
                if (isAutoPlaying && repeatsRemaining > 0) {
                    setTimeout(() => {
                        if (!isAutoPlaying) return;
                        startPlayback();
                    }, 350);
                    return;
                }

                // Start countdown for the between-cards pause
                if (isAutoPlaying) {
                    startCountdown();
                }
            };

            const startPlayback = () => {
                try { if (currentAudio) currentAudio.pause(); } catch (e) {}
                try {
                    currentAudio = new Audio(audioUrl);
                    currentAudio.onended = handleEnded;
                    visualizer.classList.remove('hidden');
                    currentAudio.play().catch(handleError);
                } catch (e) {
                    handleError(e);
                }
            };

            // Kick it off
            startPlayback();
        }

        function startCountdown() {
            let timeLeft = repeatTime;
            const progressText = document.getElementById('progressText');
            const progressCircle = document.getElementById('progressCircle');
            const circumference = 2 * Math.PI * 16; // radius = 16
            
            progressText.textContent = timeLeft;
            
            // Update every 100ms for smooth animation
            let elapsed = 0;
            const intervalTime = 100;
            const totalTime = repeatTime * 1000;
            
            countdownInterval = setInterval(() => {
                elapsed += intervalTime;
                const progress = elapsed / totalTime;
                const offset = circumference * (1 - progress);
                progressCircle.style.strokeDashoffset = offset;
                
                const newTimeLeft = Math.ceil((totalTime - elapsed) / 1000);
                if (newTimeLeft !== parseInt(progressText.textContent)) {
                    progressText.textContent = newTimeLeft;
                }
                
                if (elapsed >= totalTime) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    resetProgressRing();
                    
                    // Move to next card
                    if (isAutoPlaying) {
                        nextCard();
                    }
                }
            }, intervalTime);
        }

        function resetProgressRing() {
            const progressText = document.getElementById('progressText');
            const progressCircle = document.getElementById('progressCircle');
            const circumference = 2 * Math.PI * 16;
            
            progressText.textContent = repeatTime;
            progressCircle.style.strokeDashoffset = circumference;
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (currentMode === 'manual') {
                if (e.key === 'ArrowRight') nextCard();
                if (e.key === 'ArrowLeft') prevCard();
            }
            // Space to toggle auto play in auto mode
            if (e.key === ' ' && currentMode === 'auto') {
                e.preventDefault();
                toggleAutoPlay();
            }
        });

        // Touch swipe support (manual mode only)
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            if (currentMode === 'manual') {
                handleSwipe();
            }
        });

        function handleSwipe() {
            if (touchEndX < touchStartX - 50) nextCard();
            if (touchEndX > touchStartX + 50) prevCard();
        }
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadProgress();
            showCard(0);
            // DO NOT autoplay on load: most browsers will block it and throw NotAllowedError.
            // Instead, show a friendly prompt and unlock audio on the user's first gesture.
            showAudioUnlockPrompt('Tap once to enable audio');

            // Kid-friendly UX: tap the card (not the buttons) to flip.
            // Use a small movement threshold so swipes don't accidentally flip.
            const flashcardContainer = document.querySelector('.flashcard-container');
            let tapStart = null;

            const isInteractiveTarget = (el) => {
                if (!el) return false;
                return Boolean(el.closest('button, a, select, option, input, label, textarea, svg'));
            };

            const toggleActiveFlip = () => {
                const active = document.querySelector('.flashcard.active');
                const inner = active?.querySelector('.card-inner');
                if (!inner) return;
                // Reference-style card is single-face; don't flip.
                if (active && active.querySelector('.ref-card')) return;
                playSFX('flip');
                playTapSound();
                vibrateDevice([30]);
                inner.classList.toggle('flipped');
            };

            if (flashcardContainer) {
                flashcardContainer.addEventListener('pointerdown', (e) => {
                    if (e.pointerType === 'mouse' && e.button !== 0) return;
                    if (isInteractiveTarget(e.target)) return;
                    tapStart = { x: e.clientX, y: e.clientY };
                }, { passive: true });

                flashcardContainer.addEventListener('pointerup', (e) => {
                    if (!tapStart) return;
                    const dx = e.clientX - tapStart.x;
                    const dy = e.clientY - tapStart.y;
                    tapStart = null;

                    // Ignore if it was more like a swipe than a tap.
                    if (Math.hypot(dx, dy) > 12) return;

                    if (isInteractiveTarget(e.target)) return;

                    const active = document.querySelector('.flashcard.active');
                    if (!active || !active.contains(e.target)) return;
                    toggleActiveFlip();
                }, { passive: true });
            }

            // Unlock on first user interaction anywhere on the page.
            const firstGesture = () => unlockAudio();
            document.addEventListener('pointerdown', firstGesture, { once: true, passive: true });
            document.addEventListener('keydown', firstGesture, { once: true });

            // Page navigation links: play swoosh before leaving.
            const navLinks = document.querySelectorAll('a.back-button, .navigation-controls a.nav-button');
            navLinks.forEach((a) => {
                a.addEventListener('click', (e) => {
                    if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
                    const href = a.getAttribute('href');
                    if (!href) return;
                    e.preventDefault();
                    playSFX('nav');
                    setTimeout(() => { window.location.href = href; }, 90);
                });
            });
        });
    </script>
</body>
</html>
